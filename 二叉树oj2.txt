
144. 二叉树的前序遍历 非递归
class Solution {
public:
    //前序遍历是：根节点 左子树 右子树
    vector<int> preorderTraversal(TreeNode* root) {
        //一般二叉树的前中后序的非递归，用栈存指向节点的指针更方便，
        //用vector存节点里的数据，这里数据的顺序就是前序遍历的顺序
        stack<TreeNode*> st;
        vector<int> v;
        TreeNode* cur = root;
        
        //两种情况，第一是整个树走完；第二是栈里没有指向节点的指针
        //只要这二个只要有一个不满足，都要继续循环
        while(cur || !st.empty())
        {
            //开始访问一棵树
            //1、左路的节点
            while(cur)
            {
                //将每个根节点的值入vector，符合前序遍历
                v.push_back(cur->val);
                //将指向节点的指针存入栈，便于第2步访问左路节点的右子树
                st.push(cur);

                //继续走左路
                cur=cur->left;
            }

            //2、通过栈来访问 左路节点的右子树
            TreeNode* top=st.top();
            st.pop();

            cur=top->right;//子问题访问 左路节点的右子树
        }

        //存放在vector的数据的顺序就是前序遍历
        return v;
    }
};



94. 二叉树的中序遍历  非递归
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        //一般二叉树的前中后序的非递归，用栈存指向节点的指针更方便，
        //用vector存节点里的数据，这里数据的顺序就是中序遍历的顺序
        stack<TreeNode*> st;
        vector<int> v;
        TreeNode* cur = root;
        
        //两种情况，第一是整个树走完；第二是栈里没有指向节点的指针
        //只要这二个只要有一个不满足，都要继续循环
        while(cur || !st.empty())
        {
            //开始访问一棵树
            //1、指向左路节点的指针入栈
            while(cur)
            {
                //将指向节点的指针存入栈，便于第2步访问左路节点的右子树
                st.push(cur);
                //继续走左路节点
                cur=cur->left;
            }
        
            //2、当左路节点从栈中出来时，表示左子树已经访问完，
            //这个时候，应该访问这个节点和它的右子树
            TreeNode* top=st.top();
            st.pop();
            //将数据入栈
            v.push_back(top->val);

            cur=top->right;//子问题访问 左路节点的右子树
        }

        //存放在vector的数据的顺序就是前序遍历
        return v;
    }
};




145. 二叉树的后序遍历 非递归
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        //一般二叉树的前中后序的非递归，用栈存指向节点的指针更方便，
        //用vector存节点里的数据，这里数据的顺序就是后序遍历的顺序
        stack<TreeNode*> st;
        vector<int> v;
        TreeNode* cur = root;
        TreeNode* prev=nullptr;
        
        //两种情况，第一是整个树走完；第二是栈里没有指向节点的指针
        //只要这二个只要有一个不满足，都要继续循环
        while(cur || !st.empty())
        {
            //开始访问一棵树
            //1、指向左路节点的指针入栈
            while(cur)
            {
                //将指向节点的指针存入栈，便于第2步访问左路节点的右子树
                st.push(cur);
                //继续走左路节点
                cur=cur->left;
            }
        
            //2、当左路节点从栈中出来时，表示左子树已经访问过了
            TreeNode* top=st.top();

            //栈顶节点右子树为空 或 上一个访问节点是右子树的根，
            //说明右子树已经访问过了，可以访问这个栈顶节点；
            //否则 子问题访问top的右子树
            if(top->right==nullptr || top->right==prev)
            {
                //根节点的数据入vector
                v.push_back(top->val);
                //记录当前的top给prev
                prev=top;
                cur=nullptr;

                st.pop();
            }
            else
            {
                cur=top->right;//子问题访问右子树
            }
        }

        //存放在vector的数据的顺序就是前序遍历
        return v;
    }
};