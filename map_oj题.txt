692. 前K个高频单词
class Solution {
public:
    //自己写一个less的仿函数，为了符合题意，也是一个类
    struct less{
        //该类就是将操作符()进行重载
        bool operator()(const pair<string,int>& kv1,const pair<string,int>& kv2) const
        {
            //出现词的次数多的在前面，因为less是小于
            if(kv1.second<kv2.second)
            return true;

            //出现词的次数相等的时候，词的ASCII码值小的反而在前面，所以这里要用大于
            if(kv1.second==kv2.second && kv1.first>kv2.first)
            return true;

            return false;
        }
    };


    vector<string> topKFrequent(vector<string>& words, int k) {
        //先统计每个词出现的次序
        map<string,int> countmap;
        for(auto& str:words)
        {
            countmap[str]++;
        }

        //再找topk：即给前k个次数最多的，但是相等次数的词，
        //应该如何按顺序返回了？根据示例是按照词的ASCII码值来排升序
        //其他的词就按照出现的次数来排降序
        //第一种方法是用 优先级队列priority_queue，默认是大堆，不过要用less小于
        //类型名重定义，因为名字太长                      因为我们自己写的less没有模板参数，所以不要加
        typedef priority_queue<pair<string,int>,vector<pair<string,int>>,less> MaxHeap;
        //将容器map里的数据(类类型pair的对象) 给 类类型priority_queue的对象
        MaxHeap mh(countmap.begin(),countmap.end());

        vector<string> v;
        while(k--)//取出前k个给v
        {
            v.push_back(mh.top().first);//将堆顶的数据(类类型pair的对象) 里的变量first给v
            mh.pop();//将堆顶的数据出大堆
        }

        return v;
    }
};





349. 两个数组的交集
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        //容器set有排序+去重的特性
        //排序，是容器set底层是平衡二叉树，即容器set里的数据是按照平衡二叉树的方式放的
        //而平衡二叉树的中序遍历 遍历出来的数据是按照升序排的
        //去重是容器set不允许数据数据冗余，即key值不允许重复的
        set<int> s1(nums1.begin(),nums1.end());//去重+排序
        set<int> s2(nums2.begin(),nums2.end());//去重+排序

        //容器set的迭代器begin()就是指向的按照中序遍历后的第一个数据的空间
        set<int>::iterator it1=s1.begin();
        set<int>::iterator it2=s2.begin();

        //用于存放交集的数据
        vector<int> v;

        //下面就是在经过排序+去重的情况下才能找到交集
        while(it1!=s1.end()&&it2!=s2.end())
        {
            //小的数据++
            if((*it1)<(*it2))
            ++it1;

            //小的数据++
            if((*it2)<(*it1))
            ++it2;

            //相等的时候，就是交集
            if((*it1)==(*it2))
            {
                v.push_back((*it1));//因为相等，所以it1或it2指向的数据都可以
                ++it1;
                ++it2;
            }
        }

        return v;
    }
};