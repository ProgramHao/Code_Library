#include <iostream>
#include<queue>
using namespace std;

struct Date
{
	Date(int year, int month, int day)
		:_year(year)
		, _month(month)
		, _day(day)
	{}

	bool operator>(const Date& d) const
	{
		if ((_year > d._year)
			|| (_year == d._year && _month > d._month)
			|| (_year == d._year && _month == d._month && _day > d._day))
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator<(const Date& d) const
	{
		if ((_year < d._year)
			|| (_year == d._year && _month < d._month)
			|| (_year == d._year && _month == d._month && _day < d._day))
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	int _year;
	int _month;
	int _day;
};


// 类模板
namespace hhh
{
	template<class T>
	struct less
	{
		bool operator()(const T& x1, const T& x2) const
		{
			return x1 < x2;
		}
	};

	 //类模板特化
	template<>
	struct less<Date*>
	{
		bool operator()(Date* x1, Date* x2) const
		{
			return *x1 < *x2;
		}
	};
}

int main()
{

	Date d1(2022, 7, 7);
	Date d2(2022, 7, 8);

	Date* p1 = &d1;
	Date* p2 = &d2;



	//这里的数据是Date,用类模板less的时候，当然可以
	hhh::less<Date> lessFunc1;
	cout << lessFunc1(d1, d2) << endl;

	//这里的数据是Date*，也是指针,所以如果用类模板less的时候，
	//对于指针类型Date*是 无法处理的，所以这个时候要对类less 进行类模板特化
	hhh::less<Date*> lessFunc2;
	cout << lessFunc2(p1, p2) << endl;



	//这里的数据是Date,用类模板less的时候，当然可以
	std::priority_queue<Date, vector<Date>, hhh::less<Date>> dq1;

	//这里的数据是Date*，也是指针,所以如果用类模板less的时候，
	//对于指针类型Date*是 无法处理的，所以这个时候要对类less 进行类模板特化
	std::priority_queue<Date*, vector<Date*>, hhh::less<Date*>> dq2;
	dq2.push(new Date(2022, 9, 27));
	dq2.push(new Date(2022, 9, 25));
	dq2.push(new Date(2022, 9, 28));
	dq2.push(new Date(2022, 9, 29));


	return 0;
}