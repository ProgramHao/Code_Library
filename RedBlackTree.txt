#pragma once

#include<iostream>
#include<utility>
#include<assert.h>
#include<time.h>
using namespace std;


//颜色通过枚举即可
enum Colour
{
	//枚举变量里是常量
	RED,
	BLACK
};



//定义该类是作为红黑树的节点
template<class K, class V>
struct RBTreeNode
{
	//同样的三叉链
	RBTreeNode<K, V>* _left;
	RBTreeNode<K, V>* _right;
	RBTreeNode<K, V>* _parent;

	//类类型pair对象也作为成员变量
	pair<K, V> _kv;
	//枚举变量
	Colour _col = RED;//节点默认颜色为红色

	//构造函数
	RBTreeNode(const pair<K, V>& kv)
		:_left(nullptr) //初始化列表
		, _right(nullptr)
		, _parent(nullptr)
		, _kv(kv)
	{}
};



//定义该类就是红黑树
template<class K, class V>
struct RBTree
{
	//将类型RBTreeNode<K, V>的类型名重定义一下
	typedef RBTreeNode<K, V> Node;

public:

	//插入
	bool Insert(const pair<K, V>& kv)
	{
		//空树的情况
		if (_root == nullptr)
		{
			//因为是空树，将插入的数据 类类型pair的对象，
			//创建一个节点作为根节点
			_root = new Node(kv);
			_root->_col = BLACK;//根节点必须是黑色
			return true;
		}

		//不是空树的情况
		//给一个parent是为了链接整个二叉树
		Node* parent = nullptr;
		Node* cur = _root;
		//和搜索二叉树一样，找可以插入的位置
		while (cur)//循环找到可以插入的位置
		{
			//节点的值 小于 插入的类类型pair对象里first的值，
			if (cur->_kv.first < kv.first)
			{
				//往右子树走，找大；
				//往下走之前，先记录一下指向当前节点的指针
				parent = cur;
				cur = cur->_right;
			}
			//节点的值 大于 插入的类类型pair对象里first的值，
			else if (cur->_kv.first > kv.first)
			{
				//往左子树走，找小
				parent = cur;
				cur = cur->_left;
			}
			else
			{
				//相等就插入失败，因为AVL树是高度平衡的搜索二叉树
				//不能有相等的值
				return false;
			}
		}


		//循环结束，代码只要能走到这里，说明找到了可以插入的位置；
		//将插入数据(类类型pair的对象)，创建一个新节点cur
		cur = new Node(kv);
		//当前节点的first的值 小于 要插入的pair的first的值 
		if (parent->_kv.first < kv.first)
		{
			//该新节点插入到当前节点的右边
			parent->_right = cur;
		}
		//当前节点的first的值 大于 要插入的pair的first的值 
		else
		{
			//该新节点插入到当前节点的右边
			parent->_left = cur;
		}

		//将该节点cur里的指针_parent链接上二叉树父节点(因为是一个三叉链)
		cur->_parent = parent;


		//cur是红，p是红，g是黑，这必须是固定的，因为红黑树的性质决定
		while (parent && parent->_col == RED)
		{
			//找到当前cur的g
			Node* grandfater = parent->_parent;
			assert(grandfater);//其实可以不写，因为这必须是固定的
			assert(grandfater->_col == BLACK);//其实可以不写，因为这必须是固定的
			
			// 关键看叔叔，uncle的三种情况
			//p是g的左孩子
			if (parent == grandfater->_left)
			{
				//那么这时u就是g的右孩子
				Node* uncle = grandfater->_right;

				// 情况一 : uncle存在且为红，变色+继续往上处理
				if (uncle && uncle->_col == RED)
				{
					//解决方式：将p, u改为黑，g改为红，
					parent->_col = uncle->_col = BLACK;
					grandfater->_col = RED;
					//然后把g当成cur，继续向上调整
					cur = grandfater;
					parent = cur->_parent;
				}
				// 情况二+三：uncle不存在 + 存在且为黑
				else
				{
					// 情况二：右单旋+变色
					//		   p为g的左孩子，cur为p的左孩子，则g进行右单旋转，
					//         p、g变色--p变黑，g变红。
					//     g 
					//   p   u
					// c
					if (cur == parent->_left)
					{
						//g右单旋
						RotateR(grandfater);
						//再变色
						parent->_col = BLACK;
						grandfater->_col = RED;
					}
					else
					{
						// 情况三：左右单旋+变色
						//         p为g的左孩子，cur为p的右孩子，则针对p做左单旋转，
						//         则转换成了情况二：
						//         p为g的左孩子，cur为p的左孩子，则g进行右单旋转，
						//         p、g变色--p变黑，g变红。
						//         
						//     g 
						//   p   u
						//     c
						//p左单旋
						RotateL(parent);
						//再g右单旋
						RotateR(grandfater);
						//p、g变色--p变黑，g变红
						cur->_col = BLACK;
						grandfater->_col = RED;
					}

					//如何进入条件p是g的左孩子，那么经过上面的三种情况的判断
					//就已经调整好插入新节点后的红黑树，就可以直接跳出循环了
					break;
				}
			}
			// (parent == grandfater->_right)
			//p是g的右孩子
			else 
			{
				//那么这时候u就是g的左孩子
				Node* uncle = grandfater->_left;

				// 情况一 : uncle存在且为红，变色+继续往上处理
				if (uncle && uncle->_col == RED)
				{
					//解决方式：将p, u改为黑，g改为红，
					parent->_col = uncle->_col = BLACK;
					grandfater->_col = RED;
					// 然后把g当成cur，继续向上调整
					cur = grandfater;
					parent = cur->_parent;
				}
				// 情况二+三：uncle不存在 + 存在且为黑
				else
				{
					// 情况二：左单旋+变色
					//         p为g的右孩子，cur为p的右孩子，则进行g左单旋转，
					//         p、g变色--p变黑，g变红
					//     g 
					//   u   p
					//         c
					if (cur == parent->_right)
					{
						//g左单旋转
						RotateL(grandfater);
						//再p、g变色--p变黑，g变红
						parent->_col = BLACK;
						grandfater->_col = RED;
					}
					else
					{
						// 情况三：右左单旋+变色
						//         p为g的右孩子，cur为p的左孩子，则针对p做右单旋转，
						//         则转换成了情况2：
						//         p为g的右孩子，cur为p的右孩子，则进行g左单旋转，
						//         p、g变色--p变黑，g变红
						//         
						//     g 
						//   u   p
						//     c
						//p做右单旋转
						RotateR(parent);
						//再g左单旋转
						RotateL(grandfater);
						//再p、g变色--p变黑，g变红
						cur->_col = BLACK;
						grandfater->_col = RED;
					}

					break;
				}
			}

		}//这里是出循环

		//出循环后，不管循环内部是怎么样，我们都把根节点_root的颜色变为黑
		//因为性质1，我们就可以不用在循环内部分情况进行考虑了
		_root->_col = BLACK;
		return true;//循环结束，也就是插入完成，直接返回

	}




//这里又写了public和private只是为了方便看，其实应该是要与其他的public或private合并的
public:
	//中序遍历，因为红黑树是高度平衡的二叉树，所以中序遍历依旧是有序的
	void InOrder()
	{
		_InOrder(_root);
		cout << endl;
	}
private:
	void _InOrder(Node* root)
	{
		if (root == nullptr)
		{
			return;
		}

		_InOrder(root->_left);
		cout << root->_kv.first << ":" << root->_kv.second << endl;
		_InOrder(root->_right);
	}



//这里又写了public和private只是为了方便看，其实应该是要与其他的public或private合并的
public:
	//判断是否平衡，可以用红黑树的4条规则(性质)
	bool IsBalance()
	{
		//是空树，直接返回true
		if (_root == nullptr)
		{
			return true;
		}

		//根节点的颜色不符合规则2，直接返回false
		if (_root->_col == RED)
		{
			cout << "根节点不是黑色" << endl;
			return false;
		}



		// 黑色节点数量基准值
		int benchmark = 0;

		//上面给了个0，是可以在递归中用引用，
		// 并且在递归中当第一次从根节点_root的一条路径走到空的时候，
		// 可以给基准值benchmark给一个blackNum当作它的值
		
		//下面是自己求的从根节点_root一直到空的基准值benchmark
		/*Node* cur = _root;
		while (cur)
		{
		if (cur->_col == BLACK)
		++benchmark;

		cur = cur->_left;
		}*/



		return PrevCheck(_root, 0, benchmark);
	}
private:
	//通过前序遍历，记录根节点_root的每条路径黑色节点的数量blackNum,
	//再给一个 基准值benchmark 与 根节点_root不同路径的blackNum 是否相等
	bool PrevCheck(Node* root, int blackNum, int& benchmark)
	{
		//递归结束的条件，一直递归下去直到遇见空节点
		if (root == nullptr)
		{
			//当第一次从根节点_root的一条路径走到空的时候
			if (benchmark == 0)
			{
				//将基准值benchmark给一个值
				benchmark = blackNum;
				//这条路径就可以当作是平衡的
				return true;
			}

			//只要该节点中有一条路径的黑色节点的数量blackNum 与 基准值benchmark 不相等，
			//那么该红黑树就不满足性质4
			if (blackNum != benchmark)
			{
				cout << "某条黑色节点的数量不相等" << endl;
				return false;
			}
			else
			{
				return true;
			}
		}

		//前序遍历
		//遇到黑节点，黑色节点的数量blackNum就++一次
		if (root->_col == BLACK)
		{
			++blackNum;
		}

		//不满足红黑树的性质(规则)3，直接返回false
		if (root->_col == RED && root->_parent->_col == RED)
		{
			cout << "存在连续的红色节点" << endl;
			return false;
		}

		//继续前序递归下去
		return PrevCheck(root->_left, blackNum, benchmark)
			&& PrevCheck(root->_right, blackNum, benchmark);
	}





private:

	//左单旋
	//为什么这里不用 引用，因为我们只需要改变parent这个指针 指向的空间的内容，
	//这里并不会改变这个指针parent本身，所以不需要用引用
	void RotateL(Node* parent)
	{
		Node* subR = parent->_right;
		Node* subRL = subR->_left;

		parent->_right = subRL;
		if (subRL)//高度h可能为0，不为0才链接上
			subRL->_parent = parent;

		//先保存parent的父节点
		Node* ppNode = parent->_parent;

		subR->_left = parent;
		parent->_parent = subR;

		//当前parent是整个树的根节点
		if (_root == parent)
		{
			_root = subR;
			subR->_parent = nullptr;
		}
		//当前parent是子树的根节点
		else
		{
			//节点parent的是其父节点的左孩子
			if (ppNode->_left == parent)
			{
				ppNode->_left = subR;
			}
			//节点parent的是其父节点的右孩子
			else
			{
				ppNode->_right = subR;
			}

			subR->_parent = ppNode;
		}

	
	}




	//右单旋
	//为什么这里不用 引用，因为我们只需要改变parent这个指针 指向的空间的内容，
	//这里并不会改变这个指针parent本身，所以不需要用引用
	void RotateR(Node* parent)
	{
		Node* subL = parent->_left;
		Node* subLR = subL->_right;

		parent->_left = subLR;
		if (subLR)//高度h可能为0，不为0才链接上
			subLR->_parent = parent;

		//先保存parent的父节点
		Node* ppNode = parent->_parent;

		//链接subL和parent
		subL->_right = parent;
		parent->_parent = subL;

		//当前parent是整个树的根节点
		if (_root == parent)
		{
			//修改指向整个树根节点的指针
			_root = subL;
			subL->_parent = nullptr;//此时它的父节点就为空
		}
		//当前parent是子树的根节点
		else
		{
			//节点parent的是其父节点的左孩子
			if (ppNode->_left == parent)
			{
				ppNode->_left = subL;
			}
			//节点parent的是其父节点的右孩子
			else
			{
				ppNode->_right = subL;
			}

			//subL与父节点ppNode链接上
			subL->_parent = ppNode;
		}

	}




private:
	//该类的成员变量就只有一个，指向根节点的指针_root
	Node* _root = nullptr;//给一个缺省值
};
