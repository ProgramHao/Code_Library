HJ99 自守数
#include <iostream>
using namespace std;

int main() {
    int n,flag=0,sum=0;
    cin>>n;
    while(n)
    {
        int tmp=n;
        int mix=tmp*tmp;
        while(tmp)
        {
            if((mix%10)!=(tmp%10))
            {
            flag=1;
            break;
            }
            else
            {
            mix/=10;
            tmp/=10;
            flag=0;
            }
        }
        if(flag==0)
        sum++;
        --n;
    }
    cout<<(sum+1)<<endl;
    return 0;
}






OR86 返回小于 N 的质数个数
#include <iostream>
using namespace std;

int main() {
    int n,num=0;
    cin>>n;
    while(n!=1)
    {
        int tmp=n--,flag=0;
        for(int i=2;i<tmp;++i)
        {
            if(tmp%i==0)
            {
                flag=1;
                break;
            }
        }
        if(flag==0)
        ++num;
    }
    cout<<num;
    return 0;
}





NC31 第一个只出现一次的字符
class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        int arr[121]={0};
        for(int i=0;i<str.size();++i)
        {
            arr[str[i]]++;
        }
        for(int i=0;i<str.size();++i)
        {
            if(arr[str[i]]==1)
            return i;
        }
        return -1;
    }
};





面试题 01.01. 判定字符是否唯一
class Solution {
public:
    bool isUnique(string astr) {
        for(int i=0;i<astr.size();++i)
        {
            for(int j=i+1;j<astr.size();++j)
            {
                if(astr[i]==astr[j])
                return false;
            }
        }
        return true;
    }
};





面试题 01.02. 判定是否互为字符重排
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        if(s1.size()==s2.size())
        {
            vector<int> v1(123,0),v2(123,0);
            for(int i=0;i<s1.size();++i)
            {
                v1[s1[i]]++;
                v2[s2[i]]++;
            }
            for(int i=0;i<s1.size();++i)
            {
                if(v1[s1[i]]!=v2[s1[i]])
                return false;
            }
            return true;
        }
        else
        return false;
    }
};






面试题 01.04. 回文排列
class Solution {
public:
    bool canPermutePalindrome(string s) {
        vector<int> v(123,0);
        for(int i=0;i<s.size();++i)
        {
            v[s[i]]++;
        }
        int num=0;
        for(int i=0;i<123;++i)
        {
            if(v[i]%2==1)
            ++num;
        }
        if(num==0||num==1)
        return true;
        else
        return false;
    }
};