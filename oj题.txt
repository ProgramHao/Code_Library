//这里需要用到队列的内容


typedef int QDataType;//类型重命名

typedef struct QueueNode//节点用结构体表示
{
	struct QueueNode* next;//指向下一个节点
	QDataType data;//队列中存储的数据
}QNode;


typedef struct Queue//定义一个结构体，用来存放链表的第一个节点和尾节点
					//第一个节点用于对头出(头删)，尾节点用于队尾入(尾插)
{
	QNode* head;
	QNode* tail;
}Queue;



//初始化第一个节点和尾节点
void QueueInit(Queue* pq)
{
	assert(pq);
	pq->head = pq->tail = NULL;//初始化两个节点都用空指针NULL
}

//销毁空间，即返回每个节点开辟的空间
void QueueDestory(Queue* pq)
{
	assert(pq);

	QNode* cur = pq->head;
	while (cur)//遍历一次，直到链表最后一个节点里的指针(NULL)
	{
		QNode* next = cur->next;
		free(cur);//依次释放每个节点的空间
		cur = next;
	}

	pq->head = pq->tail = NULL;//释放完，指针head和 tail置空
}

// 队尾入(尾插)
void QueuePush(Queue* pq, QDataType x)
{
	assert(pq);
	QNode* newnode = (QNode*)malloc(sizeof(QNode));//开辟新节点
	if (newnode == NULL)//防止动态空间开辟失败
	{
		printf("malloc fail\n");
		exit(-1);//结束函数
	}

	//开辟空间成功
	newnode->data = x;//将想放的数据放入节点里
	newnode->next = NULL;//单链表节点里的指针要先赋空指针NULL

	if (pq->tail == NULL)//判断链表里是否有节点
	{
		pq->head = pq->tail = newnode;//没有节点，将新节点赋给第一个节点head和尾节点tail
	}
	else
	{
		pq->tail->next = newnode;//有节点，直接单链表尾插
		pq->tail = newnode;//尾节点向后走一位，方便写一次队尾入(尾插)
	}
}

// 队头出
void QueuePop(Queue* pq)
{
	assert(pq);

	assert(pq->head);//防止链表里没有节点，就不需要队头出(头删)

	// 1、一个
	// 2、多个
	if (pq->head->next == NULL)//如果链表里只有一个节点的时候
	{
		free(pq->head);//直接free点这节点的空间
		pq->head = pq->tail = NULL;//将指针head和tail置空
	}
	else//链表有两个及以上的节点
	{
		QNode* next = pq->head->next;//先找到第一个节点head的下一个节点next
		free(pq->head);//释放第一个节点的空间
		pq->head = next;//将节点next作为新的第一个节点，方便下一次的队列出(头删)
	}
}



//访问对头的数据(链表里的第一个节点的数据)
QDataType QueueFront(Queue* pq)
{
	assert(pq);

	assert(pq->head);//防止链表没有节点，没有节点就访问不了结构体里的数据，不然就会报错

	return pq->head->data;//访问对头(第一个节点)里的数据
}

//访问对尾的数据(链表里的尾节点的数据)
QDataType QueueBack(Queue* pq)
{
	assert(pq);

	assert(pq->head);//防止链表没有节点，没有节点就访问不了结构体里的数据，不然就会报错

	return pq->tail->data;//访问对尾(尾节点)里的数据
}

//队列(链表)里的元素个数
int QueueSize(Queue* pq)
{
	assert(pq);
	int size = 0;
	QNode* cur = pq->head;
	while (cur)//遍历一次，直到链表最后一个节点里的指针(NULL)
	{
		++size;
		cur = cur->next;
	}

	return size;
}

//判断链表里是否有元素,如果队列是空的，逻辑为真；如果队列是非空的，逻辑为假
bool QueueEmpty(Queue* pq)
{
	assert(pq);
	return pq->head == NULL;//看第一个节点是否为空指针，
							//为空就是没有元素，不为空就是有元素
}




//开始写
//这里的结构体只有关键字strcut，没有名字，这种叫匿名结构体，这种直接无法使用，但是如果前面用typedef重命名，就可以用重命名的结构体类型名字来使用它
typedef struct {
    Queue q1;//用结构体放两个队列，方便使用
    Queue q2;//这里创建的是结构体变量q1、q2；没有创建结构体指针变量，当然也可以，看自己的使用习惯
} MyStack;


//初始化两个队列
MyStack* myStackCreate() {
    MyStack* obj=(MyStack*)malloc(sizeof(MyStack));//动态申请结构体类型MyStack的空间内存
    if(obj==NULL)
    {
        perror("the mistake");//动态申请空间，不成功，可以用函数perror()来显示错误的信息
    }

    //初始化两个队列
    QueueInit(&obj->q1);//结构体变量q1的地址传递
    QueueInit(&obj->q2);//结构体变量q2的地址传递

    return obj;//返回创建成功的结构体类型MyStack的地址
}

//入栈，将数据队尾进(尾插)到 非空的队列中去
void myStackPush(MyStack* obj, int x) {
    if(QueueSize(&obj->q1))//判断哪个队列为非空队列
    {
        QueuePush(&obj->q1,x);
    }
    else
    {
        QueuePush(&obj->q2,x);
    }
}


//删除栈顶的元素
int myStackPop(MyStack* obj) {
        Queue* EmptyQ=&obj->q1;//假设q1为空队列，q2为非空队列
    Queue* NonEmptyQ=&obj->q2;

    if(QueueEmpty(&obj->q2))//假设不成立，交换
    {
        EmptyQ=&obj->q2;
        NonEmptyQ=&obj->q1;
    }

    while(QueueSize(NonEmptyQ)>1)//把 非空队列的元素 从 对头 依次顺序放入 空的队列 里面去
                                //直到非空最后一个元素留下，其他的全部传过去
    {
        QueuePush(EmptyQ,QueueFront(NonEmptyQ));//依次从对头传递过去
        QueuePop(NonEmptyQ);//非空队列对头传递一个，非空队列就对头出一个，这样循环才能依次传递除了
                           //最后一个元素的其他所有元素
    }
    int top = QueueFront(NonEmptyQ);//找到要删除的栈顶的元素，先创建临时变量存储
    QueuePop(NonEmptyQ);//传递完成后，就对头出(头删)最后一个元素(即栈顶的元素)
    return top;//删除栈顶元素后，就返回临时变量存放的栈顶元素
}


//返回栈顶的元素，肯定从非空的队列返回队尾的元素，这路的队尾就是栈顶
int myStackTop(MyStack* obj) {
    if(QueueSize(&obj->q1))//判断哪个队列为非空队列
    {
        return QueueBack(&obj->q1);//返回非空队列队尾的元素
    }
    else
    {
        return QueueBack(&obj->q2);//返回非空队列队尾的元素
    }
}


//判断栈为空，就是两个队列都为空,如果两个队列都是空的，逻辑为真；如果两个队列是只要有一个非空的，逻辑为假
bool myStackEmpty(MyStack* obj) {
    return QueueEmpty(&obj->q1) && QueueEmpty(&obj->q2);
    //或者：return QueueSize(&obj->q1)==0 && QueueSize(&obj->q1==0;
}


//释放栈的空间，即释放两个对列的空间
void myStackFree(MyStack* obj) {
    QueueDestory(&obj->q1);//销毁两个对列的空间
    QueueDestory(&obj->q2);

    free(obj);
    obj=NULL;
}

/**
 * Your MyStack struct will be instantiated and called as such:
 * MyStack* obj = myStackCreate();
 * myStackPush(obj, x);
 
 * int param_2 = myStackPop(obj);
 
 * int param_3 = myStackTop(obj);
 
 * bool param_4 = myStackEmpty(obj);
 
 * myStackFree(obj);
*/

/**
 * Your MyStack struct will be instantiated and called as such:
 * MyStack* obj = myStackCreate();
 * myStackPush(obj, x);
 
 * int param_2 = myStackPop(obj);
 
 * int param_3 = myStackTop(obj);
 
 * bool param_4 = myStackEmpty(obj);
 
 * myStackFree(obj);
*/